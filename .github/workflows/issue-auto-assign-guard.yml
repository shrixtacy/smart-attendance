name: Strict Assignment Guard

on:
  issue_comment:
    types: [created]
  issues:
    types: [assigned]

permissions:
  issues: write
  pull-requests: read

jobs:
  enforce-strict-policies:
    runs-on: ubuntu-latest
    steps:
      - name: Assignment Logic and Workload Check
        uses: actions/github-script@v7
        with:
          script: |
            const repo = context.repo;
            const issue = context.payload.issue;
            let assignee = "";
            let isAutoAssign = false;

            // =================================================================
            // 1. CONTEXT & SINGLE-ASSIGNEE POLICY
            // =================================================================
            if (context.eventName === 'issue_comment') {
              const commentBody = context.payload.comment.body.toLowerCase();
              const author = context.payload.comment.user.login;
              const intentWords = ["assign", "take", "work", "handle", "pick", "do", "fix", "solve"];
              const selfWords = ["me", "i", "myself"];
              
              const hasIntent = intentWords.some(w => commentBody.includes(w));
              const hasSelf = selfWords.some(w => commentBody.includes(w));

              if (hasIntent && hasSelf) {
                assignee = author;
                isAutoAssign = true;
                
                // Block if already assigned to someone else
                if (issue.assignees.length > 0) {
                  await github.rest.issues.createComment({
                    ...repo,
                    issue_number: issue.number,
                    body: `âš ï¸ **Already Assigned**\n\nSorry @${author}, this issue is already assigned to @${issue.assignees[0].login}. Please look for another open issue!`
                  });
                  return;
                }
              } else {
                return; // Not an assignment request
              }
            } else if (context.eventName === 'issues' && context.payload.action === 'assigned') {
              assignee = context.payload.assignee.login;
              
              // Prevent manual dual-assignment via GitHub Sidebar
              if (issue.assignees.length > 1) {
                // Find the original assignee (the one who isn't the current assignee triggering the workflow)
                const originalAssignee = issue.assignees.find(a => a.login !== assignee)?.login || issue.assignees[0].login;
                
                await github.rest.issues.removeAssignees({
                  ...repo,
                  issue_number: issue.number,
                  assignees: [assignee]
                });
                
                await github.rest.issues.createComment({
                  ...repo,
                  issue_number: issue.number,
                  body: `âš ï¸ **Single Assignee Policy**\n\nThis issue is already assigned to @${originalAssignee}. Removing @${assignee} to maintain the one-assignee-per-issue rule.`
                });
                return;
              }
            }

            // =================================================================
            // 2. BYPASS FOR BOTS & MAINTAINERS
            // =================================================================
            const maintainers = ["nem-web", "adi271001", "Suvam-paul145"];
            if (assignee.endsWith('[bot]') || assignee === 'copilot' || maintainers.includes(assignee)) {
              console.log(`Bypassing workload checks for bot/maintainer: ${assignee}`);
              return;
            }

            // =================================================================
            // 3. ON-HOLD STATUS CHECK
            // =================================================================
            const isHold = issue.labels.some(label => label.name.toLowerCase() === 'on-hold');
            if (isHold) {
              await github.rest.issues.createComment({
                ...repo,
                issue_number: issue.number,
                body: `â³ **Assignment Paused**\n\n@${assignee}, this issue is currently **on-hold**. Please wait until the label is removed.`
              });
              
              if (!isAutoAssign) {
                await github.rest.issues.removeAssignees({ ...repo, issue_number: issue.number, assignees: [assignee] });
              }
              return;
            }

            // =================================================================
            // 4. STRICT WORKLOAD CHECK (PR-to-Issue Ratio)
            // =================================================================
            const assignedIssues = await github.paginate(github.rest.issues.listForRepo, {
              ...repo,
              state: 'open',
              assignee: assignee
            });

            // Count how many OTHER open issues this user holds
            const otherIssues = assignedIssues.filter(i => i.number !== issue.number && !i.pull_request);

            if (otherIssues.length > 0) {
              // Count how many OPEN PRs this user has created in this repo
              const { data: prSearch } = await github.rest.search.issuesAndPullRequests({
                q: `is:pr is:open author:${assignee} repo:${repo.owner}/${repo.repo}`
              });

              // Strict logic: They must have at least 1 PR for EVERY assigned issue they hold.
              // Example: 2 assigned issues -> requires 2 PRs. If PRs < 2, block.
              if (otherIssues.length > prSearch.total_count) {
                const issueLinks = otherIssues.map(i => `#${i.number}`).join(', ');
                
                await github.rest.issues.createComment({
                  ...repo,
                  issue_number: issue.number,
                  body: `ðŸš« **Assignment Blocked**\n\n@${assignee}, you are currently holding **${otherIssues.length} open issue(s)** (${issueLinks}) but only have **${prSearch.total_count} open PR(s)**.\n\n**Rule:** You cannot be assigned a new issue until you have raised a PR for *every* issue currently assigned to you. Please submit your pending PRs first! ðŸš€`
                });

                // Remove the assignee (handles both manual sidebar mistakes and auto-assign blocks)
                await github.rest.issues.removeAssignees({
                  ...repo,
                  issue_number: issue.number,
                  assignees: [assignee]
                });
                return;
              }
              console.log(`âœ… Exception granted: @${assignee} has sufficient open PRs (${prSearch.total_count} PRs for ${otherIssues.length} previous issues).`);
            }

            // =================================================================
            // 5. FINALIZE AUTO-ASSIGNMENT
            // =================================================================
            if (isAutoAssign) {
              await github.rest.issues.addAssignees({
                ...repo,
                issue_number: issue.number,
                assignees: [assignee]
              });
              
              await github.rest.issues.createComment({
                ...repo,
                issue_number: issue.number,
                body: `âœ… **Assigned to @${assignee}**\n\nAll the best! Feel free to share progress updates here.`
              });
            }
